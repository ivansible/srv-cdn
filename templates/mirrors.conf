# Site mirroring
# ansible-managed

# A request can have two optional HTTP headers:
# X-Mirror-Front: desired-front-host
# X-Mirror-Back: desired-origin-host

map $http_x_mirror_front $mirror_front {
    default $http_x_mirror_front;
    ""      $http_host;
}

map $http_x_mirror_back $mirror_back {
    default $http_x_mirror_back;
    ""      $mirror_auto_back;
}

map $mirror_front $mirror_auto_back {
    hostnames;
    default  {{ srv_mirror_default_origin }};
{% for item in srv_mirror_mirrors %}
    {{ item.server }}  {{ item.origin }};
{% endfor %}
}

server {
    server_name
{% for item in srv_mirror_mirrors %}
{% if item.server != 'default' and not item.hidden |default(false) %}
        {{ item.server }}
{% endif %}
{% endfor %}
        ;
    {{ nginx_conf_listen_http }}
{% if nginx_ssl_cert %}
    {{ nginx_conf_listen_ssl }}
    ssl_certificate     {{ nginx_ssl_cert }};
    ssl_certificate_key {{ nginx_ssl_key }};
{% endif %}
    #ssl_early_data on;  # nginx 1.15.4+, needs tls 1.3, possible replay attacks

    location /  {
        # Accept either direct connections (blank forwarded proto) or SSL behind CloudFlare
        if ( $http_x_forwarded_proto !~ "^(https)?$" ) { return 301 "https://$host$uri"; }
        # Uncomment next line after enabling SSL in CloudFlare
        if ( $https != "on" ) { return 301 "https://$host$uri"; }

        proxy_pass https://$mirror_back;
        proxy_ssl_server_name on;
        proxy_redirect "~*^https?://[^/]+/(.*)$" "https://$mirror_front/$1";
        proxy_set_header Host $mirror_back;
        proxy_set_header Referer https://$mirror_back;

        proxy_set_header Accept-Encoding "";

{% for filter in srv_mirror_filters %}
        sub_filter '{{ filter.src }}'  '{{ filter.dst }}';
{% endfor %}
        sub_filter_once off;
        sub_filter_last_modified on;

        root {{ nginx_def_site_dir }};
    }

    include bastion.d/*.conf;
}
